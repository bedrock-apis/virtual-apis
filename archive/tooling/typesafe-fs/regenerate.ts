import fs from 'node:fs/promises';
import path from 'node:path';
import url from 'node:url';
import prettier from 'prettier';

import merge from 'deepmerge';
import { FS } from './directories';

// Usage
// node directories regenerate - Merges current and old directories state
// node directories regenerate clean - Saves current directories state

const SOURCES: [string, object, string][] = [
   ['dist', FS.dist, './dist'],
   ['src', FS.src, './src'],
];
const DIRECTORIES_FILE = path.join(url.fileURLToPath(import.meta.url), '../directories.ts');

try {
   console.log('Updating', DIRECTORIES_FILE);

   const entries = await Promise.all(SOURCES.map(generateEntry));
   const object = Object.fromEntries(entries);
   const root = (await generateEntry(['SRC', {}, '.', true] as const))[1];
   const full = merge(object, root);
   const code = `export const FS = ${JSON.stringify(full, null, 3)}`;

   const formatted = await prettier.format(code, {
      parser: 'acorn',
      ...(await prettier.resolveConfig(DIRECTORIES_FILE)),
   });

   await fs.writeFile(DIRECTORIES_FILE, formatted);
} catch (e) {
   console.log(`Unable to update ${DIRECTORIES_FILE}:`, e);
}

async function generateEntry([dirName, old, path, onlyDir]: [string, object, string, boolean?]) {
   const current = await objectFromDir(path, onlyDir);
   const result = process.argv.includes('clean') || dirName === 'SRC' ? current : merge(old, current);
   return [dirName, result] as const;
}

async function objectFromDir(dir: string, onlyDir = false) {
   const object: Record<string, string | Record<string, unknown>> = {};

   for (const entry of await fs.readdir(dir, { withFileTypes: true })) {
      const entrypath = './' + path.join(entry.parentPath, entry.name).replaceAll('\\', '/');
      const name = entry.name.replaceAll('.', '_').replaceAll('-', '_');
      const { ext } = path.parse(entry.name);

      // Ignore upper case because its from modules generated by rolldown
      if (entry.isFile() && ['.js', '.ts', '.json'].includes(ext) && name.toLowerCase() === name) {
         object[name] = entrypath;
      } else if (entry.isDirectory()) {
         const dir = entrypath.endsWith('/') ? entrypath : entrypath + '/';
         if (onlyDir && dir.startsWith('./.')) continue;

         object[name] = onlyDir ? { DIR: dir } : { DIR: dir, ...(await objectFromDir(entrypath)) };
      }
   }
   return object;
}
